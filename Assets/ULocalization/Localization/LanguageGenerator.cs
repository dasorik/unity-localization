using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEditor;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.IO;
using System;
using Microsoft.CSharp;

namespace ULocalization
{
	public class LanguageGenerator : AssetPostprocessor
	{
		class KeyTranslation
		{
			public string key;
			public string translation;
			public string fragmentedKey;
		}

		public static readonly string directory = Path.Combine(Application.dataPath, "Generated");
		public static readonly string filePath = Path.Combine(directory, "_GeneratedLanguage.cs");
		public static readonly string relativeAssetPath = "Assets/Generated/_GeneratedLanguage";

		static CSharpCodeProvider keywordChecker = new CSharpCodeProvider();


		static void OnPostprocessAllAssets(string[] importedAssets, string[] deletedAssets, string[] movedAssets, string[] movedFromAssetPaths)
		{
			TextAsset[] files = LocalizationConfig.GetResourceFiles();
			
			if (files == null)
				return;

			string[] paths = new string[files.Length];

			for (int i = 0; i < files.Length; i++)
				paths[i] = AssetDatabase.GetAssetPath(files[i]);

			bool shouldRegenerate = MatchesAny(paths, importedAssets)
				|| MatchesAny(paths, deletedAssets)
				|| MatchesAny(paths, movedAssets)
				|| MatchesAny(paths, movedFromAssetPaths);

			if (shouldRegenerate && LocalizationConfig.AutoGenerateLanguageClass)
				ParseAndBuildLanguageClass(files);
		}

		static bool MatchesAny(string[] list1, string[] list2)
		{
			for (int i = 0; i < list1.Length; i++)
			{
				for (int j = 0; j < list2.Length; j++)
				{
					if (list1[i] == list2[j])
						return true;
				}
			}

			return false;
		}

		public static void ParseAndBuildLanguageClass(TextAsset[] languageFiles)
		{
			Group<KeyTranslation> root = new Group<KeyTranslation>();
			List<TextAsset> parsedFiles = new List<TextAsset>();
	
			foreach (var file in languageFiles)
			{
				if (file == null || parsedFiles.Contains(file))
					continue;

				parsedFiles.Add(file);

				string[,] entries = CSVParser.ReadCSV(file, ',', '\"');
				int rows = entries.GetLength(0);

				for (int row = 1; row < rows; row++)
				{
					string[] splitKey = entries[row, 0].Split('.');
					Group<KeyTranslation> currentGroup = root;

					for (int splitIndex = 0; splitIndex < splitKey.Length; splitIndex++)
					{
						Group<KeyTranslation> child;
						if (!currentGroup.Contains(g => g.Value.fragmentedKey == splitKey[splitIndex], out child))
						{
							child = currentGroup.Add(new KeyTranslation()
							{
								key = entries[row, 0],
								fragmentedKey = splitKey[splitIndex],
								translation = splitIndex == splitKey.Length ? null : entries[row, 1]
							});
						}
						currentGroup = child;
					}
				}
			}

			if (!Directory.Exists(directory))
				Directory.CreateDirectory(directory);

			using (var writer = File.CreateText(filePath))
				BuildLanguageClass(root, writer);

			//AssetDatabase.ImportAsset(relativeAssetPath);
			AssetDatabase.Refresh();

			Debug.Log($"Generated language key file, saved result to: {filePath} ({DateTime.Now:dd/MM/yyy hh:mm:ss})");
		}

		static void BuildLanguageClass(Group<KeyTranslation> root, StreamWriter writer)
		{
			writer.WriteLine("// This file is automatically generated every time a language file is changed/reimported, DO NOT MODIFY!");
			writer.WriteLine($"// Last modified: {DateTime.Now:dd/MM/yyy hh:mm:ss}");
			writer.WriteLine();

			writer.WriteLine($"namespace {typeof(Localization).Namespace}");
			writer.WriteLine("{");
			writer.WriteLine("\tpublic class keys");
			writer.WriteLine("\t{");
			
			foreach (var child in root)
				BuildGroup(child, 2, writer);

			writer.WriteLine("\t}");
			writer.WriteLine("}");
		}

		static void BuildGroup(Group<KeyTranslation> group, int indentLevel, StreamWriter writer)
		{
			string tab = new string('\t', indentLevel);

			if (!group.IsLeafNode)
			{
				writer.WriteLine($"{tab}public static class {group.Value.fragmentedKey}");
				writer.WriteLine($"{tab}{{");

				foreach (var child in group)
					BuildGroup(child, indentLevel + 1, writer);

				writer.WriteLine($"{tab}}}");
			}
			else
			{
				// Add the intellisense summary (English translation)
				writer.WriteLine($"{tab}///<summary>{group.Value.translation}</summary>");
				
				string escapedFragmentedKey = keywordChecker.IsValidIdentifier(group.Value.fragmentedKey) ? group.Value.fragmentedKey : $"@{group.Value.fragmentedKey}";

				// Add the returned localstring
				IEnumerable<string> parameters;
				if (group.Value.translation.HasFormatParametersEscape(out parameters))
				{
					string lastParameter = parameters.Last();

					writer.Write($"{tab}public static localstring {escapedFragmentedKey}(");

					foreach (string parameter in parameters)
						writer.Write($"object {parameter}{(parameter != lastParameter ? ", " : string.Empty)}");
					
					writer.Write($") {{ return new localstring(\"{group.Value.key}\", ");

					foreach (string parameter in parameters)
						writer.Write($"{parameter}{(parameter != lastParameter ? ", " : string.Empty)}");

					writer.WriteLine("); }");
				}
				else
				{
					writer.WriteLine($"{tab}public static readonly localstring {escapedFragmentedKey} = new localstring(\"{group.Value.key}\");");
				}
			}
		}
	}
}